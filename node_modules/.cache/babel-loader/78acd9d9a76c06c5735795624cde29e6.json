{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/macbookair/Desktop/smartcontract/dappuni/eth_swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/macbookair/Desktop/smartcontract/dappuni/eth_swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nrequire(\"source-map-support/register\");\n\nvar bip39 = __importStar(require(\"bip39\"));\n\nvar EthUtil = __importStar(require(\"ethereumjs-util\"));\n\nvar ethereumjs_wallet_1 = __importDefault(require(\"ethereumjs-wallet\"));\n\nvar hdkey_1 = __importDefault(require(\"ethereumjs-wallet/hdkey\"));\n\nvar ethereumjs_tx_1 = __importDefault(require(\"ethereumjs-tx\"));\n\nvar web3_provider_engine_1 = __importDefault(require(\"web3-provider-engine\"));\n\nvar filters_1 = __importDefault(require(\"web3-provider-engine/subproviders/filters\"));\n\nvar nonce_tracker_1 = __importDefault(require(\"web3-provider-engine/subproviders/nonce-tracker\"));\n\nvar hooked_wallet_1 = __importDefault(require(\"web3-provider-engine/subproviders/hooked-wallet\"));\n\nvar provider_1 = __importDefault(require(\"web3-provider-engine/subproviders/provider\"));\n\nvar url_1 = __importDefault(require(\"url\"));\n\nvar web3_1 = __importDefault(require(\"web3\")); // Important: do not use debug module. Reason: https://github.com/trufflesuite/truffle/issues/2374#issuecomment-536109086\n// This line shares nonce state across multiple provider instances. Necessary\n// because within truffle the wallet is repeatedly newed if it's declared in the config within a\n// function, resetting nonce from tx to tx. An instance can opt out\n// of this behavior by passing `shareNonce=false` to the constructor.\n// See issue #65 for more\n\n\nvar singletonNonceSubProvider = new nonce_tracker_1.default();\n\nvar HDWalletProvider =\n/*#__PURE__*/\nfunction () {\n  function HDWalletProvider(mnemonic, provider) {\n    var _this = this;\n\n    var addressIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var numAddresses = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    var shareNonce = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var walletHdpath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"m/44'/60'/0'/0/\";\n\n    _classCallCheck(this, HDWalletProvider);\n\n    this.walletHdpath = walletHdpath;\n    this.wallets = {};\n    this.addresses = [];\n    this.engine = new web3_provider_engine_1.default();\n\n    if (!HDWalletProvider.isValidProvider(provider)) {\n      throw new Error([\"Malformed provider URL: '\".concat(provider, \"'\"), \"Please specify a correct URL, using the http, https, ws, or wss protocol.\", \"\"].join(\"\\n\"));\n    } // private helper to normalize given mnemonic\n\n\n    var normalizePrivateKeys = function normalizePrivateKeys(mnemonic) {\n      if (Array.isArray(mnemonic)) return mnemonic;else if (mnemonic && !mnemonic.includes(\" \")) return [mnemonic]; // if truthy, but no spaces in mnemonic\n      else return false; // neither an array nor valid value passed;\n    }; // private helper to check if given mnemonic uses BIP39 passphrase protection\n\n\n    var checkBIP39Mnemonic = function checkBIP39Mnemonic(mnemonic) {\n      _this.hdwallet = hdkey_1.default.fromMasterSeed(bip39.mnemonicToSeed(mnemonic));\n\n      if (!bip39.validateMnemonic(mnemonic)) {\n        throw new Error(\"Mnemonic invalid or undefined\");\n      } // crank the addresses out\n\n\n      for (var i = addressIndex; i < addressIndex + numAddresses; i++) {\n        var wallet = _this.hdwallet.derivePath(_this.walletHdpath + i).getWallet();\n\n        var addr = \"0x\".concat(wallet.getAddress().toString(\"hex\"));\n\n        _this.addresses.push(addr);\n\n        _this.wallets[addr] = wallet;\n      }\n    }; // private helper leveraging ethUtils to populate wallets/addresses\n\n\n    var ethUtilValidation = function ethUtilValidation(privateKeys) {\n      // crank the addresses out\n      for (var i = addressIndex; i < privateKeys.length; i++) {\n        var privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n\n        if (EthUtil.isValidPrivate(privateKey)) {\n          var wallet = ethereumjs_wallet_1.default.fromPrivateKey(privateKey);\n          var address = wallet.getAddressString();\n\n          _this.addresses.push(address);\n\n          _this.wallets[address] = wallet;\n        }\n      }\n    };\n\n    var privateKeys = normalizePrivateKeys(mnemonic);\n    if (!privateKeys) checkBIP39Mnemonic(mnemonic);else ethUtilValidation(privateKeys);\n    var tmp_accounts = this.addresses;\n    var tmp_wallets = this.wallets;\n    this.engine.addProvider(new hooked_wallet_1.default({\n      getAccounts: function getAccounts(cb) {\n        cb(null, tmp_accounts);\n      },\n      getPrivateKey: function getPrivateKey(address, cb) {\n        if (!tmp_wallets[address]) {\n          return cb(\"Account not found\");\n        } else {\n          cb(null, tmp_wallets[address].getPrivateKey().toString(\"hex\"));\n        }\n      },\n      signTransaction: function signTransaction(txParams, cb) {\n        var pkey;\n        var from = txParams.from.toLowerCase();\n\n        if (tmp_wallets[from]) {\n          pkey = tmp_wallets[from].getPrivateKey();\n        } else {\n          cb(\"Account not found\");\n        }\n\n        var tx = new ethereumjs_tx_1.default(txParams);\n        tx.sign(pkey);\n        var rawTx = \"0x\".concat(tx.serialize().toString(\"hex\"));\n        cb(null, rawTx);\n      },\n      signMessage: function signMessage(_ref, cb) {\n        var data = _ref.data,\n            from = _ref.from;\n        var dataIfExists = data;\n\n        if (!dataIfExists) {\n          cb(\"No data to sign\");\n        }\n\n        if (!tmp_wallets[from]) {\n          cb(\"Account not found\");\n        }\n\n        var pkey = tmp_wallets[from].getPrivateKey();\n        var dataBuff = EthUtil.toBuffer(dataIfExists);\n        var msgHashBuff = EthUtil.hashPersonalMessage(dataBuff);\n        var sig = EthUtil.ecsign(msgHashBuff, pkey);\n        var rpcSig = EthUtil.toRpcSig(sig.v, sig.r, sig.s);\n        cb(null, rpcSig);\n      },\n      signPersonalMessage: function signPersonalMessage() {\n        this.signMessage.apply(this, arguments);\n      }\n    }));\n    !shareNonce ? this.engine.addProvider(new nonce_tracker_1.default()) : this.engine.addProvider(singletonNonceSubProvider);\n    this.engine.addProvider(new filters_1.default());\n\n    if (typeof provider === \"string\") {\n      // shim Web3 to give it expected sendAsync method. Needed if web3-engine-provider upgraded!\n      // Web3.providers.HttpProvider.prototype.sendAsync =\n      // Web3.providers.HttpProvider.prototype.send;\n      var subProvider;\n      var providerProtocol = (url_1.default.parse(provider).protocol || \"http:\").toLowerCase();\n\n      switch (providerProtocol) {\n        case \"ws:\":\n        case \"wss:\":\n          subProvider = new web3_1.default.providers.WebsocketProvider(provider);\n          break;\n\n        default:\n          // @ts-ignore: Incorrect typings in @types/web3\n          subProvider = new web3_1.default.providers.HttpProvider(provider, {\n            keepAlive: false\n          });\n      }\n\n      this.engine.addProvider(new provider_1.default(subProvider));\n    } else {\n      this.engine.addProvider(new provider_1.default(provider));\n    } // Required by the provider engine.\n\n\n    this.engine.start(function (err) {\n      if (err) throw err;\n    });\n  }\n\n  _createClass(HDWalletProvider, [{\n    key: \"send\",\n    value: function send(payload, callback) {\n      return this.engine.send.call(this.engine, payload, callback);\n    }\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(payload, callback) {\n      this.engine.sendAsync.call(this.engine, payload, callback);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress(idx) {\n      if (!idx) {\n        return this.addresses[0];\n      } else {\n        return this.addresses[idx];\n      }\n    }\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses() {\n      return this.addresses;\n    }\n  }], [{\n    key: \"isValidProvider\",\n    value: function isValidProvider(provider) {\n      var validProtocols = [\"http:\", \"https:\", \"ws:\", \"wss:\"];\n\n      if (typeof provider === \"string\") {\n        var url = url_1.default.parse(provider.toLowerCase());\n        return !!(validProtocols.includes(url.protocol || \"\") && url.slashes);\n      }\n\n      return true;\n    }\n  }]);\n\n  return HDWalletProvider;\n}();\n\nmodule.exports = HDWalletProvider;","map":null,"metadata":{},"sourceType":"script"}