{"ast":null,"code":"var async = require('async');\n\nvar inherits = require('util').inherits;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar Subprovider = require('./subprovider.js');\n\nvar Stoplight = require('../util/stoplight.js');\n\nvar EventEmitter = require('events').EventEmitter;\n\nmodule.exports = FilterSubprovider; // handles the following RPC methods:\n//   eth_newBlockFilter\n//   eth_newPendingTransactionFilter\n//   eth_newFilter\n//   eth_getFilterChanges\n//   eth_uninstallFilter\n//   eth_getFilterLogs\n\ninherits(FilterSubprovider, Subprovider);\n\nfunction FilterSubprovider(opts) {\n  opts = opts || {};\n  var self = this;\n  self.filterIndex = 0;\n  self.filters = {};\n  self.filterDestroyHandlers = {};\n  self.asyncBlockHandlers = {};\n  self.asyncPendingBlockHandlers = {};\n  self._ready = new Stoplight();\n\n  self._ready.setMaxListeners(opts.maxFilters || 25);\n\n  self._ready.go();\n\n  self.pendingBlockTimeout = opts.pendingBlockTimeout || 4000;\n  self.checkForPendingBlocksActive = false; // we dont have engine immeditately\n\n  setTimeout(function () {\n    // asyncBlockHandlers require locking provider until updates are completed\n    self.engine.on('block', function (block) {\n      // pause processing\n      self._ready.stop(); // update filters\n\n\n      var updaters = valuesFor(self.asyncBlockHandlers).map(function (fn) {\n        return fn.bind(null, block);\n      });\n      async.parallel(updaters, function (err) {\n        if (err) console.error(err); // unpause processing\n\n        self._ready.go();\n      });\n    });\n  });\n}\n\nFilterSubprovider.prototype.handleRequest = function (payload, next, end) {\n  var self = this;\n\n  switch (payload.method) {\n    case 'eth_newBlockFilter':\n      self.newBlockFilter(end);\n      return;\n\n    case 'eth_newPendingTransactionFilter':\n      self.newPendingTransactionFilter(end);\n      self.checkForPendingBlocks();\n      return;\n\n    case 'eth_newFilter':\n      self.newLogFilter(payload.params[0], end);\n      return;\n\n    case 'eth_getFilterChanges':\n      self._ready.await(function () {\n        self.getFilterChanges(payload.params[0], end);\n      });\n\n      return;\n\n    case 'eth_getFilterLogs':\n      self._ready.await(function () {\n        self.getFilterLogs(payload.params[0], end);\n      });\n\n      return;\n\n    case 'eth_uninstallFilter':\n      self._ready.await(function () {\n        self.uninstallFilter(payload.params[0], end);\n      });\n\n      return;\n\n    default:\n      next();\n      return;\n  }\n};\n\nFilterSubprovider.prototype.newBlockFilter = function (cb) {\n  var self = this;\n\n  self._getBlockNumber(function (err, blockNumber) {\n    if (err) return cb(err);\n    var filter = new BlockFilter({\n      blockNumber: blockNumber\n    });\n    var newBlockHandler = filter.update.bind(filter);\n    self.engine.on('block', newBlockHandler);\n\n    var destroyHandler = function destroyHandler() {\n      self.engine.removeListener('block', newBlockHandler);\n    };\n\n    self.filterIndex++;\n    self.filters[self.filterIndex] = filter;\n    self.filterDestroyHandlers[self.filterIndex] = destroyHandler;\n    var hexFilterIndex = intToHex(self.filterIndex);\n    cb(null, hexFilterIndex);\n  });\n};\n\nFilterSubprovider.prototype.newLogFilter = function (opts, cb) {\n  var self = this;\n\n  self._getBlockNumber(function (err, blockNumber) {\n    if (err) return cb(err);\n    var filter = new LogFilter(opts);\n    var newLogHandler = filter.update.bind(filter);\n\n    var blockHandler = function blockHandler(block, cb) {\n      self._logsForBlock(block, function (err, logs) {\n        if (err) return cb(err);\n        newLogHandler(logs);\n        cb();\n      });\n    };\n\n    self.filterIndex++;\n    self.asyncBlockHandlers[self.filterIndex] = blockHandler;\n    self.filters[self.filterIndex] = filter;\n    var hexFilterIndex = intToHex(self.filterIndex);\n    cb(null, hexFilterIndex);\n  });\n};\n\nFilterSubprovider.prototype.newPendingTransactionFilter = function (cb) {\n  var self = this;\n  var filter = new PendingTransactionFilter();\n  var newTxHandler = filter.update.bind(filter);\n\n  var blockHandler = function blockHandler(block, cb) {\n    self._txHashesForBlock(block, function (err, txs) {\n      if (err) return cb(err);\n      newTxHandler(txs);\n      cb();\n    });\n  };\n\n  self.filterIndex++;\n  self.asyncPendingBlockHandlers[self.filterIndex] = blockHandler;\n  self.filters[self.filterIndex] = filter;\n  var hexFilterIndex = intToHex(self.filterIndex);\n  cb(null, hexFilterIndex);\n};\n\nFilterSubprovider.prototype.getFilterChanges = function (hexFilterId, cb) {\n  var self = this;\n  var filterId = Number.parseInt(hexFilterId, 16);\n  var filter = self.filters[filterId];\n  if (!filter) console.warn('FilterSubprovider - no filter with that id:', hexFilterId);\n  if (!filter) return cb(null, []);\n  var results = filter.getChanges();\n  filter.clearChanges();\n  cb(null, results);\n};\n\nFilterSubprovider.prototype.getFilterLogs = function (hexFilterId, cb) {\n  var self = this;\n  var filterId = Number.parseInt(hexFilterId, 16);\n  var filter = self.filters[filterId];\n  if (!filter) console.warn('FilterSubprovider - no filter with that id:', hexFilterId);\n  if (!filter) return cb(null, []);\n\n  if (filter.type === 'log') {\n    self.emitPayload({\n      method: 'eth_getLogs',\n      params: [{\n        fromBlock: filter.fromBlock,\n        toBlock: filter.toBlock,\n        address: filter.address,\n        topics: filter.topics\n      }]\n    }, function (err, res) {\n      if (err) return cb(err);\n      cb(null, res.result);\n    });\n  } else {\n    var results = [];\n    cb(null, results);\n  }\n};\n\nFilterSubprovider.prototype.uninstallFilter = function (hexFilterId, cb) {\n  var self = this;\n  var filterId = Number.parseInt(hexFilterId, 16);\n  var filter = self.filters[filterId];\n\n  if (!filter) {\n    cb(null, false);\n    return;\n  }\n\n  self.filters[filterId].removeAllListeners();\n  var destroyHandler = self.filterDestroyHandlers[filterId];\n  delete self.filters[filterId];\n  delete self.asyncBlockHandlers[filterId];\n  delete self.asyncPendingBlockHandlers[filterId];\n  delete self.filterDestroyHandlers[filterId];\n  if (destroyHandler) destroyHandler();\n  cb(null, true);\n}; // private\n// check for pending blocks\n\n\nFilterSubprovider.prototype.checkForPendingBlocks = function () {\n  var self = this;\n  if (self.checkForPendingBlocksActive) return;\n  var activePendingTxFilters = !!Object.keys(self.asyncPendingBlockHandlers).length;\n\n  if (activePendingTxFilters) {\n    self.checkForPendingBlocksActive = true;\n    self.emitPayload({\n      method: 'eth_getBlockByNumber',\n      params: ['pending', true]\n    }, function (err, res) {\n      if (err) {\n        self.checkForPendingBlocksActive = false;\n        console.error(err);\n        return;\n      }\n\n      self.onNewPendingBlock(res.result, function (err) {\n        if (err) console.error(err);\n        self.checkForPendingBlocksActive = false;\n        setTimeout(self.checkForPendingBlocks.bind(self), self.pendingBlockTimeout);\n      });\n    });\n  }\n};\n\nFilterSubprovider.prototype.onNewPendingBlock = function (block, cb) {\n  var self = this; // update filters\n\n  var updaters = valuesFor(self.asyncPendingBlockHandlers).map(function (fn) {\n    return fn.bind(null, block);\n  });\n  async.parallel(updaters, cb);\n};\n\nFilterSubprovider.prototype._getBlockNumber = function (cb) {\n  var self = this;\n  var blockNumber = bufferToNumberHex(self.engine.currentBlock.number);\n  cb(null, blockNumber);\n};\n\nFilterSubprovider.prototype._logsForBlock = function (block, cb) {\n  var self = this;\n  var blockNumber = bufferToNumberHex(block.number);\n  self.emitPayload({\n    method: 'eth_getLogs',\n    params: [{\n      fromBlock: blockNumber,\n      toBlock: blockNumber\n    }]\n  }, function (err, response) {\n    if (err) return cb(err);\n    if (response.error) return cb(response.error);\n    cb(null, response.result);\n  });\n};\n\nFilterSubprovider.prototype._txHashesForBlock = function (block, cb) {\n  var self = this;\n  var txs = block.transactions; // short circuit if empty\n\n  if (txs.length === 0) return cb(null, []); // txs are already hashes\n\n  if ('string' === typeof txs[0]) {\n    cb(null, txs); // txs are obj, need to map to hashes\n  } else {\n    var results = txs.map(function (tx) {\n      return tx.hash;\n    });\n    cb(null, results);\n  }\n}; //\n// BlockFilter\n//\n\n\ninherits(BlockFilter, EventEmitter);\n\nfunction BlockFilter(opts) {\n  // console.log('BlockFilter - new')\n  var self = this;\n  EventEmitter.apply(self);\n  self.type = 'block';\n  self.engine = opts.engine;\n  self.blockNumber = opts.blockNumber;\n  self.updates = [];\n}\n\nBlockFilter.prototype.update = function (block) {\n  // console.log('BlockFilter - update')\n  var self = this;\n  var blockHash = bufferToHex(block.hash);\n  self.updates.push(blockHash);\n  self.emit('data', block);\n};\n\nBlockFilter.prototype.getChanges = function () {\n  var self = this;\n  var results = self.updates; // console.log('BlockFilter - getChanges:', results.length)\n\n  return results;\n};\n\nBlockFilter.prototype.clearChanges = function () {\n  // console.log('BlockFilter - clearChanges')\n  var self = this;\n  self.updates = [];\n}; //\n// LogFilter\n//\n\n\ninherits(LogFilter, EventEmitter);\n\nfunction LogFilter(opts) {\n  // console.log('LogFilter - new')\n  var self = this;\n  EventEmitter.apply(self);\n  self.type = 'log';\n  self.fromBlock = opts.fromBlock !== undefined ? opts.fromBlock : 'latest';\n  self.toBlock = opts.toBlock !== undefined ? opts.toBlock : 'latest';\n  var expectedAddress = opts.address && (Array.isArray(opts.address) ? opts.address : [opts.address]);\n  self.address = expectedAddress && expectedAddress.map(normalizeHex);\n  self.topics = opts.topics || [];\n  self.updates = [];\n  self.allResults = [];\n}\n\nLogFilter.prototype.validateLog = function (log) {\n  // console.log('LogFilter - validateLog:', log)\n  var self = this; // check if block number in bounds:\n  // console.log('LogFilter - validateLog - blockNumber', self.fromBlock, self.toBlock)\n\n  if (blockTagIsNumber(self.fromBlock) && hexToInt(self.fromBlock) >= hexToInt(log.blockNumber)) return false;\n  if (blockTagIsNumber(self.toBlock) && hexToInt(self.toBlock) <= hexToInt(log.blockNumber)) return false; // address is correct:\n  // console.log('LogFilter - validateLog - address', self.address)\n\n  if (self.address && !self.address.map(function (a) {\n    return a.toLowerCase();\n  }).includes(log.address.toLowerCase())) return false; // topics match:\n  // topics are position-dependant\n  // topics can be nested to represent `or` [[a || b], c]\n  // topics can be null, representing a wild card for that position\n  // console.log('LogFilter - validateLog - topics', log.topics)\n  // console.log('LogFilter - validateLog - against topics', self.topics)\n\n  var topicsMatch = self.topics.reduce(function (previousMatched, topicPattern, index) {\n    // abort in progress\n    if (!previousMatched) return false; // wild card\n\n    if (!topicPattern) return true; // pattern is longer than actual topics\n\n    var logTopic = log.topics[index];\n    if (!logTopic) return false; // check each possible matching topic\n\n    var subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];\n    var topicDoesMatch = subtopicsToMatch.filter(function (subTopic) {\n      return logTopic.toLowerCase() === subTopic.toLowerCase();\n    }).length > 0;\n    return topicDoesMatch;\n  }, true); // console.log('LogFilter - validateLog - '+(topicsMatch ? 'approved!' : 'denied!')+' ==============')\n\n  return topicsMatch;\n};\n\nLogFilter.prototype.update = function (logs) {\n  // console.log('LogFilter - update')\n  var self = this; // validate filter match\n\n  var validLogs = [];\n  logs.forEach(function (log) {\n    var validated = self.validateLog(log);\n    if (!validated) return; // add to results\n\n    validLogs.push(log);\n    self.updates.push(log);\n    self.allResults.push(log);\n  });\n\n  if (validLogs.length > 0) {\n    self.emit('data', validLogs);\n  }\n};\n\nLogFilter.prototype.getChanges = function () {\n  // console.log('LogFilter - getChanges')\n  var self = this;\n  var results = self.updates;\n  return results;\n};\n\nLogFilter.prototype.getAllResults = function () {\n  // console.log('LogFilter - getAllResults')\n  var self = this;\n  var results = self.allResults;\n  return results;\n};\n\nLogFilter.prototype.clearChanges = function () {\n  // console.log('LogFilter - clearChanges')\n  var self = this;\n  self.updates = [];\n}; //\n// PendingTxFilter\n//\n\n\ninherits(PendingTransactionFilter, EventEmitter);\n\nfunction PendingTransactionFilter() {\n  // console.log('PendingTransactionFilter - new')\n  var self = this;\n  EventEmitter.apply(self);\n  self.type = 'pendingTx';\n  self.updates = [];\n  self.allResults = [];\n}\n\nPendingTransactionFilter.prototype.validateUnique = function (tx) {\n  var self = this;\n  return self.allResults.indexOf(tx) === -1;\n};\n\nPendingTransactionFilter.prototype.update = function (txs) {\n  // console.log('PendingTransactionFilter - update')\n  var self = this;\n  var validTxs = [];\n  txs.forEach(function (tx) {\n    // validate filter match\n    var validated = self.validateUnique(tx);\n    if (!validated) return; // add to results\n\n    validTxs.push(tx);\n    self.updates.push(tx);\n    self.allResults.push(tx);\n  });\n\n  if (validTxs.length > 0) {\n    self.emit('data', validTxs);\n  }\n};\n\nPendingTransactionFilter.prototype.getChanges = function () {\n  // console.log('PendingTransactionFilter - getChanges')\n  var self = this;\n  var results = self.updates;\n  return results;\n};\n\nPendingTransactionFilter.prototype.getAllResults = function () {\n  // console.log('PendingTransactionFilter - getAllResults')\n  var self = this;\n  var results = self.allResults;\n  return results;\n};\n\nPendingTransactionFilter.prototype.clearChanges = function () {\n  // console.log('PendingTransactionFilter - clearChanges')\n  var self = this;\n  self.updates = [];\n}; // util\n\n\nfunction normalizeHex(hexString) {\n  return hexString.slice(0, 2) === '0x' ? hexString : '0x' + hexString;\n}\n\nfunction intToHex(value) {\n  return ethUtil.intToHex(value);\n}\n\nfunction hexToInt(hexString) {\n  return Number(hexString);\n}\n\nfunction bufferToHex(buffer) {\n  return '0x' + buffer.toString('hex');\n}\n\nfunction bufferToNumberHex(buffer) {\n  return stripLeadingZero(buffer.toString('hex'));\n}\n\nfunction stripLeadingZero(hexNum) {\n  var stripped = ethUtil.stripHexPrefix(hexNum);\n\n  while (stripped[0] === '0') {\n    stripped = stripped.substr(1);\n  }\n\n  return \"0x\".concat(stripped);\n}\n\nfunction blockTagIsNumber(blockTag) {\n  return blockTag && ['earliest', 'latest', 'pending'].indexOf(blockTag) === -1;\n}\n\nfunction valuesFor(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n}","map":null,"metadata":{},"sourceType":"script"}